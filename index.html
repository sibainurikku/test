<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å°å­¦4å¹´ç”Ÿã®ãŸã‚ã®åˆ†åº¦å™¨ã‚²ãƒ¼ãƒ </title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 20px;
            box-shadow: 0 2px 20px rgba(0, 0, 0, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 20px;
        }

        .title {
            font-size: 28px;
            font-weight: bold;
            color: #2d3436;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-size: 16px;
            color: #2d3436;
            font-weight: 600;
        }

        input[type="range"] {
            width: 100px;
            height: 8px;
            border-radius: 4px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #00b894;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 184, 148, 0.3);
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .btn-primary {
            background: #00b894;
            color: white;
        }

        .btn-primary:hover {
            background: #00a085;
            transform: translateY(-2px);
        }

        .btn-reset {
            background: #e17055;
            color: white;
        }

        .btn-reset:hover {
            background: #d63031;
            transform: translateY(-2px);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #canvas {
            display: block;
            cursor: crosshair;
            background: rgba(255, 255, 255, 0.1);
        }

        .angle-display {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 32px;
            font-weight: bold;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            text-align: center;
            border: 3px solid #00b894;
        }

        .instruction-panel {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            max-width: 350px;
            font-size: 16px;
            color: #2d3436;
            line-height: 1.6;
            border: 3px solid #fdcb6e;
        }

        .instruction-title {
            font-size: 20px;
            font-weight: bold;
            color: #e17055;
            margin-bottom: 15px;
            text-align: center;
        }

        .step {
            margin-bottom: 12px;
            padding: 8px;
            background: rgba(116, 185, 255, 0.1);
            border-radius: 8px;
            border-left: 4px solid #74b9ff;
        }

        .angle-info {
            position: absolute;
            bottom: 30px;
            right: 30px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            font-size: 18px;
            color: #2d3436;
            font-weight: 600;
            border: 3px solid #a29bfe;
            min-width: 200px;
            text-align: center;
        }

        .help-message {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(0, 184, 148, 0.9);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.5s ease;
            max-width: 300px;
        }

        .help-message.show {
            opacity: 1;
        }

        /* Game specific styles */
        .game-controls {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.05);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            border-top: 1px solid #eee;
        }

        .game-controls input[type="number"] {
            padding: 10px 15px;
            border: 2px solid #a29bfe;
            border-radius: 8px;
            font-size: 18px;
            text-align: center;
            width: 100px;
            outline: none;
        }

        .game-controls input[type="number"]:focus {
            border-color: #0984e3;
        }

        .feedback-message {
            font-size: 18px;
            font-weight: bold;
            color: #2d3436;
            margin-left: 15px;
            text-align: center;
            min-width: 150px;
        }

        .score-display {
            position: absolute;
            top: 100px; /* Adjust based on header height */
            right: 30px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 10px;
            font-size: 20px;
            font-weight: bold;
            color: #2d3436;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            border: 2px solid #00b894;
        }


        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                padding: 15px;
            }
            
            .title {
                font-size: 24px;
            }

            .angle-display {
                font-size: 24px;
                padding: 15px 20px;
                top: 20px;
                right: 20px;
            }

            .instruction-panel {
                font-size: 14px;
                padding: 15px;
                top: 20px;
                left: 20px;
                max-width: 280px;
            }
            
            .angle-info {
                font-size: 16px;
                padding: 15px;
                bottom: 20px;
                right: 20px;
                min-width: 150px;
            }

            .game-controls {
                flex-direction: column;
                gap: 10px;
                padding: 10px;
            }

            .game-controls input[type="number"] {
                width: 80px;
            }

            .feedback-message {
                margin-left: 0;
                margin-top: 10px;
            }

            .score-display {
                font-size: 18px;
                top: 80px;
                right: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="title">ğŸ“ å°å­¦4å¹´ç”Ÿã®ãŸã‚ã®åˆ†åº¦å™¨ã‚²ãƒ¼ãƒ </div>
        <div class="controls">
            <div class="control-group">
                <label>å¤§ãã•:</label>
                <input type="range" id="sizeSlider" min="0.7" max="1.5" step="0.1" value="1">
            </div>
            <button class="btn btn-primary" id="showHintBtn">ğŸ’¡ ãƒ’ãƒ³ãƒˆ</button>
            <button class="btn btn-reset" id="resetBtn">ğŸ”„ ãƒªã‚»ãƒƒãƒˆ</button>
        </div>
    </div>

    <div class="canvas-container">
        <canvas id="canvas"></canvas>
        <div class="angle-display" id="angleDisplay">0Â°</div>
        
        <div class="instruction-panel">
            <div class="instruction-title">ğŸ“š åˆ†åº¦å™¨ã®ä½¿ã„æ–¹</div>
            <div class="step">
                <strong>1.</strong> åˆ†åº¦å™¨ã®ä¸­å¿ƒã‚’è§’ã®é ‚ç‚¹ã«åˆã‚ã›ã‚ˆã†
            </div>
            <div class="step">
                <strong>2.</strong> 0Â°ã®ç·šã‚’è§’ã®ä¸€ã¤ã®è¾ºã«åˆã‚ã›ã‚ˆã†
            </div>
            <div class="step">
                <strong>3.</strong> ã‚‚ã†ä¸€ã¤ã®è¾ºãŒæŒ‡ã—ã¦ã„ã‚‹ç›®ç››ã‚Šã‚’èª­ã‚‚ã†
            </div>
            <div class="step">
                <strong>4.</strong> ãƒã‚¦ã‚¹ã‚’å‹•ã‹ã—ã¦è§’åº¦ã‚’æ¸¬ã£ã¦ã¿ã‚ˆã†ï¼
            </div>
        </div>
        
        <div class="angle-info" id="angleInfo">
            è§’åº¦: 0Â°<br>
            <small>ç›´ç·š</small>
        </div>
        
        <div class="help-message" id="helpMessage">
            åˆ†åº¦å™¨ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å‹•ã‹ã™ã“ã¨ãŒã§ãã‚‹ã‚ˆï¼
        </div>

        <div class="score-display" id="scoreDisplay">
            æ­£è§£: 0 / 0
        </div>
    </div>

    <div class="game-controls">
        <div class="control-group">
            <label for="answerInput">ã“ã®è§’åº¦ã¯ä½•åº¦ã‹ãªï¼Ÿ</label>
            <input type="number" id="answerInput" min="0" max="180" placeholder="0-180">
        </div>
        <button class="btn btn-primary" id="checkAnswerBtn">âœ… ã“ãŸãˆåˆã‚ã›ï¼</button>
        <button class="btn btn-primary" id="nextQuestionBtn" style="display:none;">ğŸ‘‰ æ¬¡ã®å•é¡Œï¼</button>
        <div class="feedback-message" id="feedbackMessage"></div>
    </div>

    <script>
        class ElementaryProtractorGame {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.angleDisplay = document.getElementById('angleDisplay');
                this.angleInfo = document.getElementById('angleInfo');
                this.helpMessage = document.getElementById('helpMessage');
                this.answerInput = document.getElementById('answerInput');
                this.checkAnswerBtn = document.getElementById('checkAnswerBtn');
                this.nextQuestionBtn = document.getElementById('nextQuestionBtn');
                this.feedbackMessage = document.getElementById('feedbackMessage');
                this.scoreDisplay = document.getElementById('scoreDisplay');
                
                this.protractor = {
                    x: 400,
                    y: 300,
                    radius: 180,
                    rotation: 0,
                    scale: 1
                };
                
                this.mouse = { x: 0, y: 0 };
                this.isDragging = false;
                this.dragOffset = { x: 0, y: 0 };
                this.currentMeasuredAngle = 0; // The angle currently measured by the protractor
                this.targetAngle = 0; // The angle the student needs to guess (always 0-180)
                this.targetAngleBaseOrientation = 0; // 0 for right-facing, Math.PI for left-facing
                this.correctAnswers = 0;
                this.totalQuestions = 0;
                this.isFirstInteraction = true; // Added for initial help message
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.newQuestion(); 
                this.animate();
                this.showWelcomeMessage();
                this.updateScoreDisplay();
            }
            
            setupCanvas() {
                const resizeCanvas = () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight - document.querySelector('.header').offsetHeight - document.querySelector('.game-controls').offsetHeight - 20; 
                    this.protractor.x = this.canvas.width / 2; 
                    this.protractor.y = this.canvas.height / 2; 
                };
                
                resizeCanvas();
                window.addEventListener('resize', resizeCanvas);
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleMouseUp());
                this.canvas.addEventListener('mouseleave', () => this.handleMouseUp());
                
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                this.canvas.addEventListener('touchend', () => this.handleMouseUp());
                
                document.getElementById('sizeSlider').addEventListener('input', (e) => {
                    this.protractor.scale = parseFloat(e.target.value);
                    this.protractor.radius = 180 * this.protractor.scale;
                });
                
                document.getElementById('showHintBtn').addEventListener('click', () => this.showHint());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());

                this.checkAnswerBtn.addEventListener('click', () => this.checkAnswer());
                this.nextQuestionBtn.addEventListener('click', () => this.newQuestion());
            }
            
            showWelcomeMessage() {
                this.showMessage('åˆ†åº¦å™¨ã‚’ãƒ‰ãƒ©ãƒƒã‚°ã—ã¦å‹•ã‹ã›ã‚‹ã‚ˆï¼è¡¨ç¤ºã•ã‚ŒãŸè§’åº¦ã‚’æ¸¬ã£ã¦å…¥åŠ›ã—ã¦ã¿ã‚ˆã†ï¼', 4000);
            }
            
            showMessage(text, duration = 3000) {
                this.helpMessage.textContent = text;
                this.helpMessage.classList.add('show');
                clearTimeout(this.messageTimeout); 
                this.messageTimeout = setTimeout(() => {
                    this.helpMessage.classList.remove('show');
                }, duration);
            }
            
            getMousePos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            getTouchPos(e) {
                const rect = this.canvas.getBoundingClientRect();
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }
            
            handleMouseDown(e) {
                const pos = this.getMousePos(e);
                const distance = Math.sqrt(
                    Math.pow(pos.x - this.protractor.x, 2) + 
                    Math.pow(pos.y - this.protractor.y, 2)
                );
                
                if (distance < this.protractor.radius + 30) {
                    this.isDragging = true;
                    this.dragOffset.x = pos.x - this.protractor.x;
                    this.dragOffset.y = pos.y - this.protractor.y;
                    
                    if (this.isFirstInteraction) {
                        this.showMessage('ä¸Šæ‰‹ï¼åˆ†åº¦å™¨ã‚’å‹•ã‹ã›ãŸã­ï¼', 2000);
                        this.isFirstInteraction = false;
                    }
                }
            }
            
            handleMouseMove(e) {
                const pos = this.getMousePos(e);
                this.mouse = pos;
                
                if (this.isDragging) {
                    this.protractor.x = pos.x - this.dragOffset.x;
                    this.protractor.y = pos.y - this.dragOffset.y;
                    
                    this.protractor.x = Math.max(this.protractor.radius, Math.min(this.canvas.width - this.protractor.radius, this.protractor.x));
                    this.protractor.y = Math.max(this.protractor.radius, Math.min(this.canvas.height - this.protractor.radius, this.protractor.y));
                }
                
                this.calculateMeasuredAngle();
            }
            
            handleMouseUp() {
                this.isDragging = false;
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                const pos = this.getTouchPos(e);
                this.handleMouseDown({ clientX: pos.x + this.canvas.getBoundingClientRect().left, clientY: pos.y + this.canvas.getBoundingClientRect().top });
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                const pos = this.getTouchPos(e);
                this.handleMouseMove({ clientX: pos.x + this.canvas.getBoundingClientRect().left, clientY: pos.y + this.canvas.getBoundingClientRect().top });
            }
            
            calculateMeasuredAngle() {
                const dx = this.mouse.x - this.protractor.x;
                const dy = this.mouse.y - this.protractor.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > this.protractor.radius + 50) {
                    this.currentMeasuredAngle = 0; 
                    this.angleDisplay.textContent = `0Â°`;
                    this.angleInfo.innerHTML = `è§’åº¦: 0Â°<br><small>ç›´ç·š</small>`;
                    return;
                }
                
                let angleRad = Math.atan2(dy, dx); // Note: dy is positive down in canvas
                let angleDeg = angleRad * (180 / Math.PI);

                // Adjust for the protractor's orientation (0-180 from right to left)
                // This converts angles from the standard Cartesian (0 right, CCW) to protractor's (0 right, CW top to 180 left)
                // For a typical protractor, we're interested in the absolute angle relative to the base line.
                // If the base line is right (0 rad), angle is simply the absolute value after adjusting to 0-180.
                // If the base line is left (PI rad), angle is 180 - (angle relative to left base).

                // Normalize angle to 0-360
                if (angleDeg < 0) angleDeg += 360;

                let measuredAngleForProtractor = 0;
                if (this.protractor.rotation === 0) { // Standard right-facing protractor
                    if (angleDeg > 180) { // We only care about the top half
                         measuredAngleForProtractor = 360 - angleDeg; // Convert 181-359 to 179-1
                    } else {
                         measuredAngleForProtractor = angleDeg;
                    }
                } else { // Left-facing protractor (rotated by Math.PI)
                    // Angle relative to the left horizontal axis
                    let angleRelativeToLeft = Math.abs(angleDeg - 180); // 0 at 180, 180 at 0 and 360
                    measuredAngleForProtractor = angleRelativeToLeft;
                }
                 
                this.currentMeasuredAngle = Math.round(measuredAngleForProtractor);
                this.angleDisplay.textContent = `${this.currentMeasuredAngle}Â°`;
                
                this.updateAngleInfo(this.currentMeasuredAngle);
            }
            
            updateAngleInfo(angle) {
                let type = '';
                if (angle === 0) {
                    type = 'ç›´ç·š';
                } else if (angle < 90) {
                    type = 'é‹­è§’';
                } else if (angle === 90) {
                    type = 'ç›´è§’';
                } else if (angle < 180) {
                    type = 'éˆè§’';
                } else if (angle === 180) {
                    type = 'å¹³è§’';
                }
                
                this.angleInfo.innerHTML = `è§’åº¦: ${angle}Â°<br><small>${type}</small>`;
            }
            
            drawProtractor() {
                const ctx = this.ctx;
                const { x, y, radius, rotation } = this.protractor;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation); // Apply protractor rotation
                
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI); // Half circle from 0 to PI
                ctx.closePath();
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fill();
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Draw tick marks and numbers
                for (let i = 0; i <= 180; i += 10) {
                    const angle = (i * Math.PI) / 180; // Angle from 0 to PI
                    const cos = Math.cos(angle);
                    const sin = Math.sin(angle);
                    
                    let innerRadius, outerRadius, lineWidth;
                    
                    if (i % 30 === 0) {
                        innerRadius = radius - 40;
                        outerRadius = radius - 10;
                        lineWidth = 4;
                    } else {
                        innerRadius = radius - 25;
                        outerRadius = radius - 10;
                        lineWidth = 2;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(cos * innerRadius, sin * innerRadius); // Y-axis is positive downwards
                    ctx.lineTo(cos * outerRadius, sin * outerRadius);
                    ctx.strokeStyle = '#2d3436';
                    ctx.lineWidth = lineWidth;
                    ctx.stroke();
                    
                    if (i % 10 === 0) {
                        ctx.save();
                        // Position text outside the ticks
                        ctx.translate(cos * (radius - 50), sin * (radius - 50)); 
                        ctx.rotate(-rotation); // Un-rotate text so it's always upright
                        ctx.fillStyle = '#2d3436';
                        ctx.font = 'bold 16px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(i.toString(), 0, 0);
                        ctx.restore();
                    }
                }
                
                // Center point
                ctx.beginPath();
                ctx.arc(0, 0, 12, 0, Math.PI * 2);
                ctx.fillStyle = '#e17055';
                ctx.fill();
                ctx.strokeStyle = '#2d3436';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // 0-degree base line (right horizontal)
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(radius - 10, 0);
                ctx.strokeStyle = '#00b894';
                ctx.lineWidth = 5;
                ctx.stroke();
                
                ctx.restore();
            }
            
            drawAngleMeasurement() {
                const distance = Math.sqrt(Math.pow(this.mouse.x - this.protractor.x, 2) + Math.pow(this.mouse.y - this.protractor.y, 2));
                if (distance > this.protractor.radius + 50) {
                    return;
                }
                
                const ctx = this.ctx;
                ctx.save();
                
                // Line from center to mouse position
                ctx.beginPath();
                ctx.moveTo(this.protractor.x, this.protractor.y);
                ctx.lineTo(this.mouse.x, this.mouse.y);
                ctx.strokeStyle = '#fd79a8';
                ctx.lineWidth = 4;
                ctx.stroke();
                
                // Arc for the measured angle
                const arcRadius = 60;
                let mouseAngle = Math.atan2(this.mouse.y - this.protractor.y, this.mouse.x - this.protractor.x);
                let startAngle = this.protractor.rotation;
                let endAngle = mouseAngle;

                // Adjust arc drawing to always go from the base line to the mouse line
                // Considering the protractor's rotation and the expected 0-180 range
                if (this.protractor.rotation === 0) { // Right-facing protractor
                    if (mouseAngle < 0) mouseAngle += 2 * Math.PI; // Normalize to 0-2PI
                    startAngle = 0;
                    endAngle = mouseAngle;
                    if (endAngle > Math.PI) endAngle = Math.PI; // Clamp to 180 degrees
                } else { // Left-facing protractor (rotated PI)
                    startAngle = Math.PI;
                    endAngle = mouseAngle;
                    // If mouse is above left horizontal line (angle between 0 and -PI, or 0 and PI)
                    // We need to measure "clockwise" from PI
                    if (endAngle > Math.PI) {
                        endAngle = Math.PI * 2 - endAngle; // Convert 181-359 to angle from 0 towards 180
                        startAngle = Math.PI;
                    } else { // mouse is below left horizontal line (between PI and 2PI)
                        // This means the angle is measured towards the lower half, which is not usually done with a standard protractor.
                        // For simplicity in a 0-180 range, we'll effectively treat this as 0 degrees relative to the 180 line.
                        // Or, if we consider it in a 360 context, it's 180 - angle.
                        // For a 180-degree protractor, we essentially want the absolute difference from 180.
                        startAngle = Math.PI;
                        endAngle = Math.abs(mouseAngle);
                    }
                    ctx.arc(this.protractor.x, this.protractor.y, arcRadius, startAngle, endAngle, true); // true for counter-clockwise if needed
                    ctx.strokeStyle = '#fdcb6e';
                    ctx.lineWidth = 5;
                    ctx.stroke();
                    ctx.restore();
                    return;
                }

                ctx.beginPath();
                ctx.arc(this.protractor.x, this.protractor.y, arcRadius, startAngle + this.protractor.rotation, endAngle + this.protractor.rotation, false);
                ctx.strokeStyle = '#fdcb6e';
                ctx.lineWidth = 5;
                ctx.stroke();
                
                ctx.restore();
            }

            drawTargetAngle() {
                const ctx = this.ctx;
                const { x, y, radius } = this.protractor;

                ctx.save();
                ctx.translate(x, y);

                // Base line for the target angle
                // This line will either be right-facing (0) or left-facing (Math.PI)
                const baseLineX = radius * Math.cos(this.targetAngleBaseOrientation);
                const baseLineY = radius * Math.sin(this.targetAngleBaseOrientation);
                
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(baseLineX, baseLineY);
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Second line for the target angle
                // The actual angle needs to be relative to the base orientation.
                let angleFromBase = this.targetAngle; // This is the 0-180 angle
                let actualTargetAngleRad;

                if (this.targetAngleBaseOrientation === 0) { // Right-facing base
                    actualTargetAngleRad = (angleFromBase * Math.PI) / 180;
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(radius * Math.cos(actualTargetAngleRad), -radius * Math.sin(actualTargetAngleRad)); // -sin for canvas Y-axis
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                } else { // Left-facing base (Math.PI)
                    // For a clock-wise angle from the left horizontal, convert it to standard radians.
                    // If targetAngle is 30, it means 30 degrees clockwise from left.
                    // In standard cartesian (0 right, CCW), this would be 180 + 30 = 210 degrees.
                    // Or, if measuring with a protractor where 0 is left and clockwise towards bottom,
                    // we want 180 - angle.
                    actualTargetAngleRad = Math.PI - (angleFromBase * Math.PI) / 180; // Angle for the other ray
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(radius * Math.cos(actualTargetAngleRad), -radius * Math.sin(actualTargetAngleRad));
                    ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }

                ctx.restore();
            }
            
            showHint() {
                const hints = [
                    'åˆ†åº¦å™¨ã®ä¸­å¿ƒã‚’è§’ã®é ‚ç‚¹ã«åˆã‚ã›ã¦ã­ï¼',
                    'åˆ†åº¦å™¨ã®0Â°ã®ç·šã‚’è§’ã®ä¸€ã¤ã®è¾ºã«åˆã‚ã›ã‚ˆã†ï¼',
                    'ã‚‚ã†ä¸€ã¤ã®è¾ºãŒæŒ‡ã—ã¦ã„ã‚‹ç›®ç››ã‚Šã‚’ã‚ˆãè¦‹ã¦ã­ï¼',
                    '90Â°ã¯ç›´è§’ã€180Â°ã¯å¹³è§’ã ã‚ˆï¼',
                    'ãƒã‚¦ã‚¹ã‚’å‹•ã‹ã—ã¦è‰²ã€…ãªè§’åº¦ã‚’è©¦ã—ã¦ã¿ã‚ˆã†ï¼',
                    `ã“ã®è§’åº¦ã¯${this.targetAngle}Â°ã«è¿‘ã„ã‹ãªï¼Ÿ`
                ];
                
                const randomHint = hints[Math.floor(Math.random() * hints.length)];
                this.showMessage(randomHint, 3000);
            }
            
            reset() {
                this.protractor.x = this.canvas.width / 2;
                this.protractor.y = this.canvas.height / 2;
                this.protractor.rotation = 0;
                this.currentMeasuredAngle = 0;
                this.angleDisplay.textContent = '0Â°';
                this.angleInfo.innerHTML = 'è§’åº¦: 0Â°<br><small>ç›´ç·š</small>';
                this.showMessage('ãƒªã‚»ãƒƒãƒˆã—ãŸã‚ˆï¼ã¾ãŸæ¸¬ã£ã¦ã¿ã‚ˆã†ï¼', 2000);
                this.correctAnswers = 0;
                this.totalQuestions = 0;
                this.updateScoreDisplay();
                this.newQuestion(); 
            }

            newQuestion() {
                this.targetAngle = Math.floor(Math.random() * 181); // Random angle between 0 and 180
                // Randomly choose base orientation: 0 (right) or Math.PI (left)
                this.targetAngleBaseOrientation = Math.random() < 0.5 ? 0 : Math.PI;

                // Adjust protractor to match the base orientation of the target angle
                // This makes it easier for the student to align the protractor
                this.protractor.rotation = this.targetAngleBaseOrientation;

                this.angleDisplay.textContent = `ï¼ŸÂ°`; 
                this.angleInfo.innerHTML = `è§’åº¦: ã‚ã‹ã‚‰ãªã„<br><small>ã“ã‚Œã‚’æ¸¬ã£ã¦ã¿ã‚ˆã†ï¼</small>`;
                this.answerInput.value = '';
                this.feedbackMessage.textContent = '';
                this.checkAnswerBtn.style.display = 'inline-block';
                this.nextQuestionBtn.style.display = 'none';
                this.canvas.style.cursor = 'crosshair'; 
                this.isDragging = false; 
                this.updateScoreDisplay();
                this.showMessage('æ–°ã—ã„å•é¡Œã ã‚ˆï¼ã“ã®è§’åº¦ã‚’æ¸¬ã£ã¦ã¿ã‚ˆã†ï¼', 3000);
            }

            checkAnswer() {
                const userAnswer = parseInt(this.answerInput.value);
                if (isNaN(userAnswer) || userAnswer < 0 || userAnswer > 180) {
                    this.showMessage('0ã‹ã‚‰180ã®æ•°å­—ã§ç­”ãˆã¦ã­ï¼', 2000);
                    return;
                }

                this.totalQuestions++;
                this.angleDisplay.textContent = `${this.currentMeasuredAngle}Â°`; 

                // Check answer with a tolerance of 2 degrees
                if (Math.abs(userAnswer - this.targetAngle) <= 2) { 
                    this.feedbackMessage.textContent = 'ğŸ’® å¤§æ­£è§£ï¼ã‚„ã£ãŸã­ï¼';
                    this.feedbackMessage.style.color = '#00b894';
                    this.correctAnswers++;
                    this.showMessage('ãŠã‚ã§ã¨ã†ï¼æ­£è§£ã ã‚ˆï¼', 2500);
                } else {
                    this.feedbackMessage.textContent = `æ®‹å¿µï¼æ­£è§£ã¯ ${this.targetAngle}Â° ã ã‚ˆã€‚`;
                    this.feedbackMessage.style.color = '#e17055';
                    this.showMessage(`æ®‹å¿µï¼æ­£è§£ã¯ ${this.targetAngle}Â° ã ã£ãŸã‚ˆã€‚`, 3000);
                }
                
                this.updateScoreDisplay();
                this.checkAnswerBtn.style.display = 'none';
                this.nextQuestionBtn.style.display = 'inline-block';
            }

            updateScoreDisplay() {
                this.scoreDisplay.textContent = `æ­£è§£: ${this.correctAnswers} / ${this.totalQuestions}`;
            }
            
            animate() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawProtractor();
                this.drawTargetAngle(); 
                this.drawAngleMeasurement(); 
                
                requestAnimationFrame(() => this.animate());
            }
        }
        
        window.addEventListener('DOMContentLoaded', () => {
            new ElementaryProtractorGame();
        });
    </script>
</body>
</html>
